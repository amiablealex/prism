from datetime import datetime
import random
import time
import json

class PrismWarsGame:
    def __init__(self, game_id, max_players=2):
        self.game_id = game_id
        self.max_players = max_players
        self.players = []
        self.state = 'waiting'
        self.board_size = 16  # Changed from 15 to 16 for perfect center
        self.board = []
        self.light_sources = []
        self.current_player = 0
        self.round_number = 1
        self.max_rounds = 15
        self.winner = None

        self.pieces_per_player = {
            'mirror': 8,
            'prism': 1,
            'blocker': 4,
            'splitter': 3,
            'portal': 1  # 1 pair per player
        }        
        
        self.player_inventory = []
        self.amplifier_tiles = []
        self.protected_zones = []
        self.blocker_exclusion_zones = []
        self.win_points = 75
        self.objectives = []
        self.completed_objectives = []
        self.last_piece_placement = None  # Track last placed piece (x, y, player_idx)
        self.portal_pairs = {}
        self.portal_placement_in_progress = None
        
        # Energy system
        self.energy_per_turn = 2
        self.player_energy = []
        self.piece_costs = {
            'mirror': 2,
            'splitter': 4,
            'prism': 8,
            'blocker': 3,
            'portal': 6
        }
        self.pickup_cost = 1
        
        # Portal tracking
        self.portal_pairs = {}  # {player_idx: {'portal_a': (x, y), 'portal_b': (x, y)}}
        self.portal_placement_in_progress = None  # {'player': idx, 'first_portal': (x, y)}
        
        # Turn timer system
        self.turn_timer_seconds = 60
        self.turn_start_time = None
        self.missed_turns = {}
        self.disconnected_players = set()
        
        # Connection health
        self.last_heartbeat = {}
        self.disconnect_grace_period = 30
        self.pending_disconnects = {}
        
        self.created_at = datetime.now()
        self.started_at = None
    
    def initialize_board(self):
        """Initialize the game board and light sources"""
        self.board = [[None for _ in range(self.board_size)] for _ in range(self.board_size)]

        self.player_inventory = []
        for _ in self.players:
            self.player_inventory.append({
                'mirror': self.pieces_per_player['mirror'],
                'prism': self.pieces_per_player['prism'],
                'blocker': self.pieces_per_player['blocker'],
                'splitter': self.pieces_per_player['splitter'],
                'portal': self.pieces_per_player['portal']
            })        

        self.portal_pairs = {}
        self.portal_placement_in_progress = None
        
        self.player_energy = [4 for _ in self.players]
        
        self._initialize_light_sources()
        self._generate_amplifier_tiles()
        self._create_protected_zones()
        self._create_blocker_exclusion_zones()
        self._assign_objectives()
        
        self.completed_objectives = [set() for _ in self.players]
        
        self.turn_start_time = time.time()
        self.missed_turns = {i: 0 for i in range(len(self.players))}
        self.disconnected_players = set()
        self.last_heartbeat = {i: time.time() for i in range(len(self.players))}
        self.pending_disconnects = {}
        
        self.started_at = datetime.now()
    
    def _initialize_light_sources(self):
        """Place light sources - 2 per player"""
        self.light_sources = []
        
        if len(self.players) == 2:
            positions_p0 = [(3, 0, 'down'), (0, 3, 'right')]
            positions_p1 = [(12, 15, 'up'), (15, 12, 'left')]
            
            for x, y, direction in positions_p0:
                self.light_sources.append({
                    'x': x if direction in ['up', 'down'] else (-1 if direction == 'right' else self.board_size),
                    'y': y if direction in ['left', 'right'] else (-1 if direction == 'down' else self.board_size),
                    'direction': direction,
                    'player': 0,
                    'color': self.players[0]['color']
                })
            
            for x, y, direction in positions_p1:
                self.light_sources.append({
                    'x': x if direction in ['up', 'down'] else (-1 if direction == 'right' else self.board_size),
                    'y': y if direction in ['left', 'right'] else (-1 if direction == 'down' else self.board_size),
                    'direction': direction,
                    'player': 1,
                    'color': self.players[1]['color']
                })
        
        elif len(self.players) == 3:
            all_positions = [
                [(3, 0, 'down'), (0, 4, 'right')],
                [(15, 6, 'left'), (11, 15, 'up')],
                [(0, 11, 'right'), (4, 15, 'up')]
            ]
            for i in range(3):
                for x, y, direction in all_positions[i]:
                    self.light_sources.append({
                        'x': x if direction in ['up', 'down'] else (-1 if direction == 'right' else self.board_size),
                        'y': y if direction in ['left', 'right'] else (-1 if direction == 'down' else self.board_size),
                        'direction': direction,
                        'player': i,
                        'color': self.players[i]['color']
                    })
        
        elif len(self.players) == 4:
            all_positions = [
                [(3, 0, 'down'), (0, 3, 'right')],
                [(12, 0, 'down'), (15, 3, 'left')],
                [(3, 15, 'up'), (0, 12, 'right')],
                [(12, 15, 'up'), (15, 12, 'left')]
            ]
            for i in range(4):
                for x, y, direction in all_positions[i]:
                    self.light_sources.append({
                        'x': x if direction in ['up', 'down'] else (-1 if direction == 'right' else self.board_size),
                        'y': y if direction in ['left', 'right'] else (-1 if direction == 'down' else self.board_size),
                        'direction': direction,
                        'player': i,
                        'color': self.players[i]['color']
                    })
    
    def _generate_amplifier_tiles(self):
        """Generate 5 random amplifier tiles"""
        self.amplifier_tiles = []
        attempts = 0
        while len(self.amplifier_tiles) < 5 and attempts < 100:
            x = random.randint(4, self.board_size - 5)
            y = random.randint(4, self.board_size - 5)
            if (x, y) not in self.amplifier_tiles:
                self.amplifier_tiles.append((x, y))
            attempts += 1
    
    def _create_protected_zones(self):
        """Create 2-cell buffer zones around light sources"""
        self.protected_zones = []
        
        for source in self.light_sources:
            if source['direction'] == 'down':
                entry_x, entry_y = source['x'], 0
            elif source['direction'] == 'up':
                entry_x, entry_y = source['x'], self.board_size - 1
            elif source['direction'] == 'right':
                entry_x, entry_y = 0, source['y']
            else:
                entry_x, entry_y = self.board_size - 1, source['y']
            
            for dist in range(2):
                dx, dy = self._get_direction_delta(source['direction'])
                px = entry_x + dx * dist
                py = entry_y + dy * dist
                if 0 <= px < self.board_size and 0 <= py < self.board_size:
                    self.protected_zones.append((px, py))
    
    def _create_blocker_exclusion_zones(self):
        """Create 3-cell buffer zones for blockers"""
        self.blocker_exclusion_zones = []
        
        for source in self.light_sources:
            if source['direction'] == 'down':
                entry_x, entry_y = source['x'], 0
            elif source['direction'] == 'up':
                entry_x, entry_y = source['x'], self.board_size - 1
            elif source['direction'] == 'right':
                entry_x, entry_y = 0, source['y']
            else:
                entry_x, entry_y = self.board_size - 1, source['y']
            
            for dist in range(3):
                dx, dy = self._get_direction_delta(source['direction'])
                px = entry_x + dx * dist
                py = entry_y + dy * dist
                if 0 <= px < self.board_size and 0 <= py < self.board_size:
                    self.blocker_exclusion_zones.append((px, py))

    def _is_border_cell(self, x, y):
        """Check if a cell is on the border (edge)"""
        return (x == 0 or x == self.board_size - 1 or 
                y == 0 or y == self.board_size - 1)
    
    def _get_portal_exit_direction(self, x, y):
        """Get the direction light exits a portal based on which wall it's on"""
        if y == 0:  # Top edge
            return 'down'
        elif y == self.board_size - 1:  # Bottom edge
            return 'up'
        elif x == 0:  # Left edge
            return 'right'
        elif x == self.board_size - 1:  # Right edge
            return 'left'
        return None

    def _assign_objectives(self):
        """Assign objectives to each player"""
        all_objectives = [
            {'id': 'corners', 'name': 'Control All 4 Corners', 'points': 15, 'description': 'Control all 4 corner cells'},
            {'id': 'center', 'name': 'Dominate Center', 'points': 12, 'description': 'Control the center 2x2 area'},
            {'id': 'border_dominance', 'name': 'Border Dominance', 'points': 12, 'description': 'Control 15+ edge cells'},
            {'id': 'amplifier_control', 'name': 'Power Surge', 'points': 12, 'description': 'Control 3+ amplifier tiles'},
            {'id': 'expansionist', 'name': 'Expansionist', 'points': 12, 'description': 'Control 5+ cells in each quadrant'},
        ]
    
        self.objectives = []
        for _ in self.players:
            player_objectives = random.sample(all_objectives, 2)
            self.objectives.append(player_objectives)
    
    def update_heartbeat(self, player_idx):
        """Update last heartbeat time for a player"""
        self.last_heartbeat[player_idx] = time.time()
        
        if player_idx in self.pending_disconnects:
            del self.pending_disconnects[player_idx]
    
    def check_disconnections(self):
        """Check for players who haven't sent heartbeat"""
        current_time = time.time()
        
        for player_idx in range(len(self.players)):
            if player_idx in self.disconnected_players:
                continue
            
            time_since_heartbeat = current_time - self.last_heartbeat.get(player_idx, current_time)
            
            if time_since_heartbeat > 15:
                if player_idx not in self.pending_disconnects:
                    self.pending_disconnects[player_idx] = current_time
                elif current_time - self.pending_disconnects[player_idx] > self.disconnect_grace_period:
                    pass
    
    def handle_reconnection(self, player_idx):
        """Handle player reconnection"""
        self.missed_turns[player_idx] = 0
        self.disconnected_players.discard(player_idx)
        
        if player_idx in self.pending_disconnects:
            del self.pending_disconnects[player_idx]
        
        self.last_heartbeat[player_idx] = time.time()
    
    def get_time_remaining(self):
        """Get remaining time for current turn"""
        if not self.turn_start_time:
            return self.turn_timer_seconds
        
        elapsed = time.time() - self.turn_start_time
        remaining = max(0, self.turn_timer_seconds - elapsed)
        return int(remaining)
    
    def check_turn_timeout(self):
        """Check if current turn has timed out"""
        if not self.turn_start_time:
            return False
        
        elapsed = time.time() - self.turn_start_time
        return elapsed >= self.turn_timer_seconds
    
    def handle_turn_timeout(self):
        """Handle a turn timeout"""
        current_player_idx = self.current_player
        
        self.missed_turns[current_player_idx] = self.missed_turns.get(current_player_idx, 0) + 1
        
        if self.missed_turns[current_player_idx] >= 3:
            self.disconnected_players.add(current_player_idx)
            
            active_players = [i for i in range(len(self.players)) if i not in self.disconnected_players]
            if len(active_players) <= 1:
                if active_players:
                    self.force_end_game(active_players[0])
                else:
                    self.force_end_game(None)
                return True
        
        self.next_turn()
        return False
    
    def can_afford_action(self, player_idx, action_type, piece_type=None):
        """Check if player can afford an action"""
        if action_type == 'place':
            cost = self.piece_costs.get(piece_type, 0)
        elif action_type == 'pickup':
            cost = self.pickup_cost
        else:
            return False
        
        return self.player_energy[player_idx] >= cost
    
    def spend_energy(self, player_idx, amount):
        """Spend energy for a player"""
        self.player_energy[player_idx] = max(0, self.player_energy[player_idx] - amount)
    
    def gain_energy(self, player_idx):
        """Gain energy at start of turn"""
        self.player_energy[player_idx] += self.energy_per_turn
    
    def pickup_piece(self, x, y, player_idx):
        """Pick up a piece from the board"""
        if x < 0 or x >= self.board_size or y < 0 or y >= self.board_size:
            return False, "Invalid coordinates"

        piece = self.board[y][x]
        if piece is None:
            return False, "No piece to pick up"
        
        if piece['type'] == 'portal':
            return False, "Cannot pick up portals - they are permanent once placed"
        
        piece = self.board[y][x]
        if piece is None:
            return False, "No piece to pick up"
        
        if piece['player'] != player_idx:
            return False, "Can only pick up your own pieces"
        
        if not self.can_afford_action(player_idx, 'pickup'):
            return False, f"Not enough energy (need {self.pickup_cost})"
        
        piece_type = piece['type']
        self.player_inventory[player_idx][piece_type] += 1
        
        self.board[y][x] = None
        
        self.spend_energy(player_idx, self.pickup_cost)
        
        return True, "Piece picked up"
    
    def place_piece(self, x, y, piece_type, rotation=0):
        """Place a piece on the board - portals require two placements, others end turn immediately"""
        if x < 0 or x >= self.board_size or y < 0 or y >= self.board_size:
            return False, "Invalid coordinates"
        
        # Portal-specific validation
        if piece_type == 'portal':
            if not self._is_border_cell(x, y):
                return False, "Portals can only be placed on border edges"
            
            # Check if there's a portal placement in progress
            if self.portal_placement_in_progress:
                # Placing second portal
                if self.portal_placement_in_progress['player'] != self.current_player:
                    return False, "Another player's portal placement in progress"
                
                first_portal = self.portal_placement_in_progress['first_portal']
                
                # Can't place both portals on same cell
                if (x, y) == first_portal:
                    return False, "Cannot place both portals on same cell"
                
                # Place second portal
                player_idx = self.current_player
                
                self.board[y][x] = {
                    'type': 'portal',
                    'player': player_idx,
                    'rotation': 0,
                    'color': self.players[player_idx]['color'],
                    'pair_id': player_idx
                }
                
                # Update first portal's data
                fy, fx = first_portal[1], first_portal[0]
                self.board[fy][fx]['pair_id'] = player_idx
                
                # Store portal pair
                self.portal_pairs[player_idx] = {
                    'portal_a': first_portal,
                    'portal_b': (x, y)
                }
                
                # Decrement inventory (was reserved on first placement)
                self.player_inventory[player_idx]['portal'] -= 1
                
                # Clear in-progress state
                self.portal_placement_in_progress = None
                
                self.last_piece_placement = (x, y, player_idx)
                self.missed_turns[player_idx] = 0
                
                # End turn after second portal
                self.next_turn()
                
                return True, "Portal pair placed successfully"
            else:
                # Placing first portal
                player_idx = self.current_player
                
                if self.player_inventory[player_idx]['portal'] <= 0:
                    return False, "No portal pairs remaining in inventory"
                
                if not self.can_afford_action(player_idx, 'place', 'portal'):
                    cost = self.piece_costs['portal']
                    return False, f"Not enough energy (need {cost}, have {self.player_energy[player_idx]})"
                
                # Place first portal
                self.board[y][x] = {
                    'type': 'portal',
                    'player': player_idx,
                    'rotation': 0,
                    'color': self.players[player_idx]['color'],
                    'pair_id': player_idx
                }
                
                # Spend energy (reserved until second portal placed)
                cost = self.piece_costs['portal']
                self.spend_energy(player_idx, cost)
                
                # Mark placement in progress
                self.portal_placement_in_progress = {
                    'player': player_idx,
                    'first_portal': (x, y)
                }
                
                self.last_piece_placement = (x, y, player_idx)
                
                return True, "First portal placed - place second portal on another border cell"
        
        # Non-portal pieces (original logic)
        if piece_type == 'blocker' and (x, y) in self.blocker_exclusion_zones:
            return False, "Blockers cannot be placed within 3 cells of light sources"
        
        if piece_type != 'blocker' and (x, y) in self.protected_zones:
            return False, "Cannot place in protected zone near light sources"
        
        if self.board[y][x] is not None:
            return False, "Cell already occupied"
        
        if piece_type not in ['mirror', 'prism', 'blocker', 'splitter']:
            return False, "Invalid piece type"
        
        player_idx = self.current_player
        
        if self.player_inventory[player_idx][piece_type] <= 0:
            return False, f"No {piece_type}s remaining in inventory"
        
        if not self.can_afford_action(player_idx, 'place', piece_type):
            cost = self.piece_costs[piece_type]
            return False, f"Not enough energy (need {cost}, have {self.player_energy[player_idx]})"
        
        self.board[y][x] = {
            'type': piece_type,
            'player': player_idx,
            'rotation': rotation,
            'color': self.players[player_idx]['color']
        }
        
        self.player_inventory[player_idx][piece_type] -= 1
        
        cost = self.piece_costs[piece_type]
        self.spend_energy(player_idx, cost)
        
        self.last_piece_placement = (x, y, player_idx)
        self.missed_turns[player_idx] = 0
        
        self.next_turn()
        
        return True, "Piece placed successfully"

    def cancel_portal_placement(self, player_idx):
        """Cancel an in-progress portal placement"""
        if not self.portal_placement_in_progress:
            return False, "No portal placement in progress"
        
        if self.portal_placement_in_progress['player'] != player_idx:
            return False, "Not your portal placement"
        
        # Remove first portal from board
        first_portal = self.portal_placement_in_progress['first_portal']
        fx, fy = first_portal
        self.board[fy][fx] = None
        
        # Refund energy
        cost = self.piece_costs['portal']
        self.player_energy[player_idx] += cost
        
        # Clear in-progress state
        self.portal_placement_in_progress = None
        
        return True, "Portal placement cancelled"

    def next_turn(self):
        """Move to the next player's turn"""
        # Store the starting player to detect when we complete a full round
        starting_player = self.current_player
        
        self.current_player = (self.current_player + 1) % len(self.players)
        
        attempts = 0
        while self.current_player in self.disconnected_players and attempts < len(self.players):
            self.current_player = (self.current_player + 1) % len(self.players)
            attempts += 1
        
        self.gain_energy(self.current_player)
        
        self.turn_start_time = time.time()
        
        # Get active players (non-disconnected)
        active_players = [i for i in range(len(self.players)) if i not in self.disconnected_players]
        
        # Increment round when we cycle back to the first active player
        # OR if all players are disconnected
        if (active_players and self.current_player == min(active_players) and 
            starting_player != self.current_player) or attempts >= len(self.players):
            self.round_number += 1
            
            if self.round_number > self.max_rounds:
                self.end_game()
            else:
                detailed_scores = self.calculate_detailed_scores()
                for player_idx, score_data in enumerate(detailed_scores):
                    if player_idx not in self.disconnected_players and score_data['total'] >= self.win_points:
                        self.end_game()
                        break
    
    def calculate_light_paths(self):
        """Calculate all light beam paths and territory control"""
        territory = [[set() for _ in range(self.board_size)] for _ in range(self.board_size)]
        
        for source in self.light_sources:
            if source['player'] not in self.disconnected_players:
                self._trace_light_beam(source, territory)
        
        return territory
    
    def calculate_light_paths_with_preview(self, preview_x, preview_y, preview_piece_type, preview_rotation):
        """Calculate light paths with a preview piece"""
        original_piece = self.board[preview_y][preview_x]
        
        self.board[preview_y][preview_x] = {
            'type': preview_piece_type,
            'player': self.current_player,
            'rotation': preview_rotation,
            'color': self.players[self.current_player]['color']
        }
        
        territory = self.calculate_light_paths()
        
        self.board[preview_y][preview_x] = original_piece
        
        return territory
    
    def get_light_beam_segments(self):
        """Get all light beam segments for animation"""
        segments = []
        
        for source in self.light_sources:
            if source['player'] not in self.disconnected_players:
                source_segments = self._trace_beam_segments(source)
                segments.extend(source_segments)
        
        return segments
    
    def _trace_beam_segments(self, source, visited=None):
        """Trace beam and return segments"""
        if visited is None:
            visited = set()
        
        segments = []
        x, y = source['x'], source['y']
        direction = source['direction']
        player = source['player']
        color = source['color']
        
        dx, dy = self._get_direction_delta(direction)
        x += dx
        y += dy
        
        segment_start = None
        max_iterations = self.board_size * 2
        iterations = 0
        
        while iterations < max_iterations:
            iterations += 1
            
            if x < 0 or x >= self.board_size or y < 0 or y >= self.board_size:
                if segment_start:
                    segments.append({
                        'x1': segment_start[0],
                        'y1': segment_start[1],
                        'x2': x - dx,
                        'y2': y - dy,
                        'color': color,
                        'player': player
                    })
                break
            
            if (x, y) not in visited:
                visited.add((x, y))
                if segment_start is None:
                    segment_start = (x, y)
            
            piece = self.board[y][x]
            
            if piece is None:
                x += dx
                y += dy
                continue
            
            if segment_start:
                segments.append({
                    'x1': segment_start[0],
                    'y1': segment_start[1],
                    'x2': x,
                    'y2': y,
                    'color': color,
                    'player': player
                })
                segment_start = None
            
            piece_type = piece['type']
            
            if piece_type == 'blocker':
                break
            
            elif piece_type == 'portal':
                # Check if this portal has a pair
                portal_owner = piece['player']
                if portal_owner in self.portal_pairs:
                    pair_data = self.portal_pairs[portal_owner]
                    portal_a = pair_data['portal_a']
                    portal_b = pair_data['portal_b']
                    
                    # End current segment at portal entrance
                    if segment_start:
                        segments.append({
                            'x1': segment_start[0],
                            'y1': segment_start[1],
                            'x2': x,
                            'y2': y,
                            'color': color,
                            'player': player
                        })
                    
                    # Determine exit portal
                    if (x, y) == portal_a:
                        exit_portal = portal_b
                    elif (x, y) == portal_b:
                        exit_portal = portal_a
                    else:
                        break
                    
                    # Get exit direction based on exit portal's wall position
                    exit_direction = self._get_portal_exit_direction(exit_portal[0], exit_portal[1])
                    if exit_direction:
                        # Teleport to exit portal
                        x, y = exit_portal[0], exit_portal[1]
                        direction = exit_direction
                        dx, dy = self._get_direction_delta(direction)
                        segment_start = (x, y)
                        x += dx
                        y += dy
                    else:
                        break
                else:
                    break
            
            elif piece_type == 'mirror':
                rotation = piece['rotation']
                direction = self._reflect_direction(direction, rotation)
                dx, dy = self._get_direction_delta(direction)
                segment_start = (x, y)
                x += dx
                y += dy
            
            elif piece_type == 'prism':
                rotation = piece['rotation']
                new_directions = self._prism_split(direction, rotation)
                
                for new_dir in new_directions[1:]:
                    new_source = {
                        'x': x,
                        'y': y,
                        'direction': new_dir,
                        'player': player,
                        'color': color
                    }
                    segments.extend(self._trace_beam_segments(new_source, visited.copy()))
                
                if new_directions:
                    direction = new_directions[0]
                    dx, dy = self._get_direction_delta(direction)
                    segment_start = (x, y)
                    x += dx
                    y += dy
                else:
                    break
            
            elif piece_type == 'splitter':
                new_directions = self._splitter_split(direction)
                
                for new_dir in new_directions[1:]:
                    new_source = {
                        'x': x,
                        'y': y,
                        'direction': new_dir,
                        'player': player,
                        'color': color
                    }
                    segments.extend(self._trace_beam_segments(new_source, visited.copy()))
                
                if new_directions:
                    direction = new_directions[0]
                    dx, dy = self._get_direction_delta(direction)
                    segment_start = (x, y)
                    x += dx
                    y += dy
                else:
                    break
        
        return segments
    
    def _trace_light_beam(self, source, territory, visited=None):
        """Trace a single light beam through the board"""
        if visited is None:
            visited = set()
        
        x, y = source['x'], source['y']
        direction = source['direction']
        player = source['player']
        
        dx, dy = self._get_direction_delta(direction)
        x += dx
        y += dy
        
        max_iterations = self.board_size * 2
        iterations = 0
        
        while iterations < max_iterations:
            iterations += 1
            
            if x < 0 or x >= self.board_size or y < 0 or y >= self.board_size:
                break
            
            if (x, y) not in visited:
                territory[y][x].add(player)
                visited.add((x, y))
            
            piece = self.board[y][x]
            
            if piece is None:
                x += dx
                y += dy
                continue

            piece_type = piece['type']
            
            if piece_type == 'blocker':
                break
            
            elif piece_type == 'portal':
                # Check if this portal has a pair
                portal_owner = piece['player']
                if portal_owner in self.portal_pairs:
                    pair_data = self.portal_pairs[portal_owner]
                    portal_a = pair_data['portal_a']
                    portal_b = pair_data['portal_b']
                    
                    # Determine which portal we're at and get the other one
                    if (x, y) == portal_a:
                        exit_portal = portal_b
                    elif (x, y) == portal_b:
                        exit_portal = portal_a
                    else:
                        # Incomplete pair, portal doesn't work
                        break
                    
                    # Get exit direction based on exit portal's wall position
                    exit_direction = self._get_portal_exit_direction(exit_portal[0], exit_portal[1])
                    if exit_direction:
                        # Teleport to exit portal
                        x, y = exit_portal[0], exit_portal[1]
                        direction = exit_direction
                        dx, dy = self._get_direction_delta(direction)
                        x += dx
                        y += dy
                    else:
                        break
                else:
                    # No pair, portal doesn't work
                    break
            
            elif piece_type == 'mirror':            
                rotation = piece['rotation']
                direction = self._reflect_direction(direction, rotation)
                dx, dy = self._get_direction_delta(direction)
                x += dx
                y += dy
            
            elif piece_type == 'prism':
                rotation = piece['rotation']
                new_directions = self._prism_split(direction, rotation)
                
                for new_dir in new_directions[1:]:
                    new_source = {
                        'x': x,
                        'y': y,
                        'direction': new_dir,
                        'player': player,
                        'color': source['color']
                    }
                    self._trace_light_beam(new_source, territory, visited.copy())
                
                if new_directions:
                    direction = new_directions[0]
                    dx, dy = self._get_direction_delta(direction)
                    x += dx
                    y += dy
                else:
                    break
            
            elif piece_type == 'splitter':
                new_directions = self._splitter_split(direction)
                
                for new_dir in new_directions[1:]:
                    new_source = {
                        'x': x,
                        'y': y,
                        'direction': new_dir,
                        'player': player,
                        'color': source['color']
                    }
                    self._trace_light_beam(new_source, territory, visited.copy())
                
                if new_directions:
                    direction = new_directions[0]
                    dx, dy = self._get_direction_delta(direction)
                    x += dx
                    y += dy
                else:
                    break
    
    def _splitter_split(self, direction):
        """Split light into 2 perpendicular beams"""
        all_directions = ['up', 'right', 'down', 'left']
        current_idx = all_directions.index(direction)
        
        left_dir = all_directions[(current_idx - 1) % 4]
        right_dir = all_directions[(current_idx + 1) % 4]
        
        return [left_dir, right_dir]
    
    def _get_direction_delta(self, direction):
        """Get x, y delta for a direction"""
        deltas = {
            'up': (0, -1),
            'down': (0, 1),
            'left': (-1, 0),
            'right': (1, 0)
        }
        return deltas[direction]
    
    def _reflect_direction(self, direction, rotation):
        """Reflect a light beam based on mirror rotation"""
        if rotation % 180 == 0:
            reflections = {
                'up': 'left',
                'down': 'right',
                'left': 'up',
                'right': 'down'
            }
        else:
            reflections = {
                'up': 'right',
                'down': 'left',
                'left': 'down',
                'right': 'up'
            }
        
        return reflections.get(direction, direction)
    
    def _prism_split(self, direction, rotation):
        """Split light into 3 beams"""
        all_directions = ['up', 'right', 'down', 'left']
        current_idx = all_directions.index(direction)
        
        straight = direction
        left_dir = all_directions[(current_idx - 1) % 4]
        right_dir = all_directions[(current_idx + 1) % 4]
        
        return [straight, left_dir, right_dir]
    
    def calculate_detailed_scores(self):
        """Calculate detailed scores"""
        territory = self.calculate_light_paths()
        base_scores = {i: 0 for i in range(len(self.players))}
        
        for y in range(self.board_size):
            for x in range(self.board_size):
                controllers = territory[y][x]
                
                if len(controllers) == 1:
                    player = list(controllers)[0]
                    if player not in self.disconnected_players:
                        if (x, y) in self.amplifier_tiles:
                            base_scores[player] += 3
                        else:
                            base_scores[player] += 1
        
        combo_scores = self._calculate_combos(territory)
        objective_scores = self._calculate_objectives(territory)
        
        detailed_scores = []
        for i in range(len(self.players)):
            detailed_scores.append({
                'player_index': i,
                'base_territory': base_scores[i],
                'combos': combo_scores[i],
                'objectives': objective_scores[i],
                'total': base_scores[i] + combo_scores[i]['total'] + objective_scores[i]['total'],
                'is_disconnected': i in self.disconnected_players
            })
        
        return detailed_scores

    def _calculate_combos(self, territory):
        """Calculate combo bonuses - mirror chains and longest beam"""
        combo_scores = []

        # First, find the longest beam across all players
        longest_beam_players = []
        longest_beam_length = 0
        
        for player_idx in range(len(self.players)):
            if player_idx in self.disconnected_players:
                continue
            
            player_longest = self._find_longest_beam(player_idx)
            if player_longest > longest_beam_length:
                longest_beam_length = player_longest
                longest_beam_players = [player_idx]
            elif player_longest == longest_beam_length and player_longest > 0:
                longest_beam_players.append(player_idx)
        
        # Only award if there's a single winner
        longest_beam_player = longest_beam_players[0] if len(longest_beam_players) == 1 else None
        
        for player_idx in range(len(self.players)):
            if player_idx in self.disconnected_players:
                combo_scores.append({'perfect_reflection': 0, 'longest_beam': 0, 'total': 0, 'details': []})
                continue
            
            combos = {
                'perfect_reflection': 0,
                'longest_beam': 0,
                'total': 0,
                'details': []
            }
            
            # Find mirror chains along actual light paths
            mirror_chains = self._find_mirror_chains_in_light_paths(player_idx)
            for chain_length in mirror_chains:
                if chain_length >= 3:
                    bonus = 5 * (chain_length - 2)
                    combos['perfect_reflection'] += bonus
                    combos['details'].append(f"Mirror Chain x{chain_length}: +{bonus}")
            
            # Award longest beam bonus
            if player_idx == longest_beam_player and longest_beam_length >= 8:
                combos['longest_beam'] = 10
                combos['details'].append(f"Longest Beam ({longest_beam_length} cells): +10")
            
            combos['total'] = combos['perfect_reflection'] + combos['longest_beam']
            combo_scores.append(combos)
        
        return combo_scores

    def _find_longest_beam(self, player_idx):
        """Find the longest uninterrupted beam path for a player"""
        max_length = 0
        
        # Get player's light sources
        player_sources = [s for s in self.light_sources if s['player'] == player_idx]
        
        for source in player_sources:
            beam_length = self._trace_beam_length(source)
            if beam_length > max_length:
                max_length = beam_length
        
        return max_length
    
    def _trace_beam_length(self, source, visited=None):
        """Trace a beam and return its length in cells"""
        if visited is None:
            visited = set()
        
        x, y = source['x'], source['y']
        direction = source['direction']
        
        dx, dy = self._get_direction_delta(direction)
        x += dx
        y += dy
        
        length = 0
        max_iterations = self.board_size * 3
        iterations = 0
        
        while iterations < max_iterations:
            iterations += 1
            
            if x < 0 or x >= self.board_size or y < 0 or y >= self.board_size:
                break
            
            if (x, y) in visited:
                break
            
            visited.add((x, y))
            length += 1
            
            piece = self.board[y][x]
            
            if piece is None:
                x += dx
                y += dy
                continue

            piece_type = piece['type']
            
            if piece_type == 'blocker':
                break
            
            elif piece_type == 'portal':
                # Check if this portal has a pair
                portal_owner = piece['player']
                if portal_owner in self.portal_pairs:
                    pair_data = self.portal_pairs[portal_owner]
                    portal_a = pair_data['portal_a']
                    portal_b = pair_data['portal_b']
                    
                    # Determine exit portal
                    if (x, y) == portal_a:
                        exit_portal = portal_b
                    elif (x, y) == portal_b:
                        exit_portal = portal_a
                    else:
                        break
                    
                    # Get exit direction
                    exit_direction = self._get_portal_exit_direction(exit_portal[0], exit_portal[1])
                    if exit_direction:
                        # Teleport to exit portal
                        x, y = exit_portal[0], exit_portal[1]
                        direction = exit_direction
                        dx, dy = self._get_direction_delta(direction)
                        x += dx
                        y += dy
                    else:
                        break
                else:
                    break
            
            elif piece_type == 'mirror':            
                rotation = piece['rotation']
                direction = self._reflect_direction(direction, rotation)
                dx, dy = self._get_direction_delta(direction)
                x += dx
                y += dy
            
            elif piece['type'] in ['prism', 'splitter']:
                # For split beams, trace each branch and take the longest
                if piece['type'] == 'prism':
                    rotation = piece['rotation']
                    new_directions = self._prism_split(direction, rotation)
                else:
                    new_directions = self._splitter_split(direction)
                
                max_branch_length = 0
                for new_dir in new_directions:
                    new_source = {
                        'x': x,
                        'y': y,
                        'direction': new_dir,
                        'player': source['player'],
                        'color': source['color']
                    }
                    branch_length = self._trace_beam_length(new_source, visited.copy())
                    if branch_length > max_branch_length:
                        max_branch_length = branch_length
                
                return length + max_branch_length
        
        return length
    
    def _find_mirror_chains_in_light_paths(self, player_idx):
        """Find chains of mirrors along actual light beam paths"""
        chains = []
        
        # Get player's light sources
        player_sources = [s for s in self.light_sources if s['player'] == player_idx]
        
        for source in player_sources:
            chain_length = self._trace_mirror_chain_in_beam(source)
            if chain_length >= 3:
                chains.append(chain_length)
        
        return chains

    def _trace_mirror_chain_in_beam(self, source, visited=None):
        """Trace along a light beam and count consecutive mirrors owned by the same player"""
        if visited is None:
            visited = set()
        
        x, y = source['x'], source['y']
        direction = source['direction']
        player = source['player']
        
        dx, dy = self._get_direction_delta(direction)
        x += dx
        y += dy
        
        consecutive_mirrors = 0
        max_consecutive = 0
        
        max_iterations = self.board_size * 2
        iterations = 0
        
        while iterations < max_iterations:
            iterations += 1
            
            if x < 0 or x >= self.board_size or y < 0 or y >= self.board_size:
                break
            
            if (x, y) in visited:
                break
            
            visited.add((x, y))
            
            piece = self.board[y][x]
            
            if piece is None:
                # Empty cell - continue beam, don't break chain
                x += dx
                y += dy
                continue
            
            if piece['type'] == 'blocker':
                # Blocker stops beam - save current chain and stop
                if consecutive_mirrors > max_consecutive:
                    max_consecutive = consecutive_mirrors
                break
            
            elif piece['type'] == 'mirror':
                if piece['player'] == player:
                    # Same player's mirror - increment chain
                    consecutive_mirrors += 1
                    rotation = piece['rotation']
                    direction = self._reflect_direction(direction, rotation)
                    dx, dy = self._get_direction_delta(direction)
                    x += dx
                    y += dy
                else:
                    # Different player's mirror - breaks chain, save it, then continue
                    if consecutive_mirrors > max_consecutive:
                        max_consecutive = consecutive_mirrors
                    consecutive_mirrors = 0
                    rotation = piece['rotation']
                    direction = self._reflect_direction(direction, rotation)
                    dx, dy = self._get_direction_delta(direction)
                    x += dx
                    y += dy
            
            elif piece['type'] in ['prism', 'splitter']:
                # Prism/splitter breaks the chain - save current chain and stop
                if consecutive_mirrors > max_consecutive:
                    max_consecutive = consecutive_mirrors
                break
            
            else:
                break
        
        # Check final chain length
        if consecutive_mirrors > max_consecutive:
            max_consecutive = consecutive_mirrors
        
        return max_consecutive

    def _calculate_prism_cascade(self, player_idx, territory):
        """Calculate bonus for prism/splitter usage"""
        bonus = 0
        
        for y in range(self.board_size):
            for x in range(self.board_size):
                piece = self.board[y][x]
                if piece and piece['player'] == player_idx:
                    if piece['type'] in ['prism', 'splitter']:
                        local_territory = 0
                        for dy in range(-2, 3):
                            for dx in range(-2, 3):
                                ny, nx = y + dy, x + dx
                                if 0 <= nx < self.board_size and 0 <= ny < self.board_size:
                                    if player_idx in territory[ny][nx]:
                                        local_territory += 1
                        
                        if local_territory >= 10:
                            bonus += 3
        
        return bonus
    
    def _calculate_objectives(self, territory):
        """Calculate objective completion bonuses"""
        objective_scores = []
        
        for player_idx in range(len(self.players)):
            if player_idx in self.disconnected_players:
                objective_scores.append({'completed': [], 'total': 0})
                continue
            
            score = {
                'completed': [],
                'total': 0
            }
            
            for objective in self.objectives[player_idx]:
                obj_id = objective['id']
                completed = False
                
                if obj_id == 'corners':
                    corners = [(0, 0), (self.board_size-1, 0), (0, self.board_size-1), (self.board_size-1, self.board_size-1)]
                    completed = all(player_idx in territory[y][x] and len(territory[y][x]) == 1 for x, y in corners)
                
                elif obj_id == 'center':
                    # 16x16 board, perfect center is cells (7,7), (8,7), (7,8), (8,8)
                    center_cells = [(7, 7), (8, 7), (7, 8), (8, 8)]
                    completed = all(player_idx in territory[y][x] and len(territory[y][x]) == 1 for x, y in center_cells)

                elif obj_id == 'border_dominance':
                    edge_count = 0
                    for x in range(self.board_size):
                        if player_idx in territory[0][x] and len(territory[0][x]) == 1:
                            edge_count += 1
                        if player_idx in territory[self.board_size-1][x] and len(territory[self.board_size-1][x]) == 1:
                            edge_count += 1
                    for y in range(1, self.board_size-1):
                        if player_idx in territory[y][0] and len(territory[y][0]) == 1:
                            edge_count += 1
                        if player_idx in territory[y][self.board_size-1] and len(territory[y][self.board_size-1]) == 1:
                            edge_count += 1
                    completed = edge_count >= 15

                elif obj_id == 'amplifier_control':
                    amp_count = sum(1 for x, y in self.amplifier_tiles 
                                   if player_idx in territory[y][x] and len(territory[y][x]) == 1)
                    completed = amp_count >= 3

                elif obj_id == 'expansionist':
                    # Count cells in each quadrant
                    quadrant_counts = [0, 0, 0, 0]
                    for y in range(self.board_size):
                        for x in range(self.board_size):
                            if player_idx in territory[y][x] and len(territory[y][x]) == 1:
                                if x < 8 and y < 8:
                                    quadrant_counts[0] += 1
                                elif x >= 8 and y < 8:
                                    quadrant_counts[1] += 1
                                elif x < 8 and y >= 8:
                                    quadrant_counts[2] += 1
                                else:
                                    quadrant_counts[3] += 1
                    # Need 5+ cells in each quadrant
                    completed = all(count >= 5 for count in quadrant_counts)

                if completed:
                    score['completed'].append(objective)
                    score['total'] += objective['points']
            
            objective_scores.append(score)
        
        return objective_scores
    
    def calculate_territory_control(self):
        """Calculate basic territory scores"""
        detailed_scores = self.calculate_detailed_scores()
        return {i: score['base_territory'] for i, score in enumerate(detailed_scores)}
    
    def get_scores(self):
        """Get current scores for all players with full breakdown"""
        detailed_scores = self.calculate_detailed_scores()
        return [
            {
                'player': self.players[i]['username'],
                'color': self.players[i]['color'],
                'score': detailed_scores[i]['total'],
                'breakdown': detailed_scores[i]
            }
            for i in range(len(self.players))
        ]
    
    def force_end_game(self, winner_idx):
        """Force end game due to disconnections"""
        self.state = 'finished'
        
        if winner_idx is None:
            self.winner = {
                'username': 'No Winner',
                'color': '#FFFFFF',
                'score': 0,
                'breakdown': None
            }
        else:
            detailed_scores = self.calculate_detailed_scores()
            self.winner = {
                'username': self.players[winner_idx]['username'],
                'color': self.players[winner_idx]['color'],
                'score': detailed_scores[winner_idx]['total'],
                'breakdown': detailed_scores[winner_idx]
            }
    
    def end_game(self):
        """End the game and determine winner"""
        self.state = 'finished'
        detailed_scores = self.calculate_detailed_scores()
        
        active_scores = [(i, score) for i, score in enumerate(detailed_scores) if i not in self.disconnected_players]
        
        if not active_scores:
            self.winner = {
                'username': 'No Winner',
                'color': '#FFFFFF',
                'score': 0,
                'breakdown': None
            }
            return
        
        max_score = max(score['total'] for _, score in active_scores)
        winners = [i for i, score in active_scores if score['total'] == max_score]
        
        if len(winners) == 1:
            self.winner = {
                'username': self.players[winners[0]]['username'],
                'color': self.players[winners[0]]['color'],
                'score': max_score,
                'breakdown': detailed_scores[winners[0]]
            }
        else:
            self.winner = {
                'username': 'Tie',
                'color': '#FFFFFF',
                'score': max_score,
                'breakdown': None
            }
    
    def to_dict(self):
        """Convert game to dictionary for JSON serialization"""
        return {
            'game_id': self.game_id,
            'max_players': self.max_players,
            'players': self.players,
            'state': self.state,
            'board': self.board,
            'board_size': self.board_size,
            'light_sources': self.light_sources,
            'current_player': self.current_player,
            'round_number': self.round_number,
            'max_rounds': self.max_rounds,
            'winner': self.winner,
            'player_inventory': self.player_inventory,
            'player_energy': self.player_energy,
            'amplifier_tiles': self.amplifier_tiles,
            'protected_zones': self.protected_zones,
            'blocker_exclusion_zones': self.blocker_exclusion_zones,
            'win_points': self.win_points,
            'objectives': self.objectives,
            'completed_objectives': [list(s) for s in self.completed_objectives],
            'turn_start_time': self.turn_start_time,
            'missed_turns': self.missed_turns,
            'disconnected_players': list(self.disconnected_players),
            'last_heartbeat': self.last_heartbeat,
            'last_piece_placement': self.last_piece_placement,

            'pending_disconnects': self.pending_disconnects,
            'created_at': self.created_at.isoformat() if hasattr(self, 'created_at') else None,
            'started_at': self.started_at.isoformat() if hasattr(self, 'started_at') else None
        }
    
    @classmethod
    def from_dict(cls, data):
        """Create game from dictionary"""
        game = cls(data['game_id'], data['max_players'])
        game.players = data['players']
        game.state = data['state']
        game.board = data['board']
        game.board_size = data['board_size']
        game.light_sources = data['light_sources']
        game.current_player = data['current_player']
        game.round_number = data['round_number']
        game.max_rounds = data['max_rounds']
        game.winner = data['winner']
        game.player_inventory = data['player_inventory']
        game.player_energy = data.get('player_energy', [4] * len(data['players']))
        game.amplifier_tiles = [tuple(t) for t in data['amplifier_tiles']]
        game.protected_zones = [tuple(z) for z in data['protected_zones']]
        game.blocker_exclusion_zones = [tuple(z) for z in data.get('blocker_exclusion_zones', [])]
        game.win_points = data['win_points']
        game.objectives = data['objectives']
        game.completed_objectives = [set(s) for s in data.get('completed_objectives', [[] for _ in data['players']])]
        game.turn_start_time = data.get('turn_start_time')
        game.missed_turns = data.get('missed_turns', {})
        game.disconnected_players = set(data.get('disconnected_players', []))
        game.last_heartbeat = data.get('last_heartbeat', {})
        game.pending_disconnects = data.get('pending_disconnects', {})
        game.last_piece_placement = data.get('last_piece_placement')
        
        if data.get('created_at'):
            game.created_at = datetime.fromisoformat(data['created_at'])
        if data.get('started_at'):
            game.started_at = datetime.fromisoformat(data['started_at'])
        
        return game
    
    def get_state(self):
        """Get the full game state for clients"""
        territory = self.calculate_light_paths()
        
        return {
            'game_id': self.game_id,
            'players': self.players,
            'state': self.state,
            'board': self.board,
            'board_size': self.board_size,
            'last_piece_placement': self.last_piece_placement,
            'light_sources': self.light_sources,
            'current_player': self.current_player,
            'round_number': self.round_number,
            'max_rounds': self.max_rounds,
            'winner': self.winner,
            'player_inventory': self.player_inventory,
            'player_energy': self.player_energy,
            'energy_per_turn': self.energy_per_turn,
            'piece_costs': self.piece_costs,
            'pickup_cost': self.pickup_cost,
            'territory': [[list(cell) for cell in row] for row in territory],
            'scores': self.get_scores(),
            'amplifier_tiles': self.amplifier_tiles,
            'protected_zones': self.protected_zones,
            'blocker_exclusion_zones': self.blocker_exclusion_zones,
            'win_points': self.win_points,
            'objectives': self.objectives,
            'light_beam_segments': self.get_light_beam_segments(),
            'time_remaining': self.get_time_remaining(),
            'disconnected_players': list(self.disconnected_players),
            'missed_turns': self.missed_turns
        }
